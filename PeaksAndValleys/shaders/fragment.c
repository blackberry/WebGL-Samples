/*
* Copyright (c) 2012 Research In Motion Limited.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
 * This shader colours our terrain and blends the various textures together based on how high the vertex is.
 * The lowest point will emphasize sand, while the highest point will emphasize snow. Inbetween we have
 * rock and grass. This can even be expanded on (i.e. for very sloped surface, emphasize rock instead of grass, etc.)
 *
 * Many thanks to Chandler Prall for writing about how to blend textures here:
 * http://chandler.prallfamily.com/2011/06/blending-webgl-textures
 */

precision mediump float;		// We will use medium precision floats.

varying vec2 vTextureCoord;		// The value of the texture coordinates. Shared across all textures.
varying vec3 vPosition;			// The position of the vertex. Used to retrieve the height.
varying vec3 vLightWeighting;	// The light weighting assigned to this vertex. Shadows are neat.

uniform sampler2D texture0;		// Our sand texture.
uniform sampler2D texture1;		// Our grass texture.
uniform sampler2D texture2;		// Our rock texture.
uniform sampler2D texture3;		// Our snow texture.

void main(void) {
	/**
	 * Here we assign colour vectors to each of our textures, based on the specific coordinate.
	 *
	 * We are actually not using anye textures in the code below, and simply relying on a direct colours.
	 * If we want, we can replace the colours with some (or all) of the textures we've actually passed in
	 * and blend them together as we see fit.
	 *
	 * vec4 color represent our base colour (i.e. what to draw in lieu of any textures being applied. We assign white in this case.
	 *
	 * Disclaimer: This current method of blending textures does take quite a performance hit. More optimized
	 * 			   approaches will need to be explored.
	 */
	vec4 diffuseSand = vec4(0.8, 1.0, 0.0, 1.0);	// texture2D(texture0, vec2(vTextureCoord.s, vTextureCoord.t));
	vec4 diffuseGrass = vec4(0.0, 0.8, 0.2, 1.0);	// texture2D(texture1, vec2(vTextureCoord.s, vTextureCoord.t));
	vec4 diffuseRock = vec4(0.5, 0.5, 0.5, 1.0);	// texture2D(texture2, vec2(vTextureCoord.s, vTextureCoord.t));
	vec4 diffuseSnow = vec4(1.0, 1.0, 1.0, 1.0);	// texture2D(texture3, vec2(vTextureCoord.s, vTextureCoord.t));
	vec4 color = vec4(1.0, 1.0, 1.0, 1.0);

	/**
	 * Each call to mix has the following "anatomy":
	 * newResult = mix(whatAreWeMixing, whatAreWeMixingWith, min(abs(baseHeight - vertexHeight) / colourRange, alpha));
	 *
	 * Where:
	 * - newResult				represents the colour of the two blended values.
	 * - whatAreWeMixing		represents the colour we are adding.
	 * - whatAreWeMixingWith	represents the colour we are adding to.
	 * - baseHeight				represents the vertex height at which whatAreWeMixing is applied at 100%.
	 * - vertexHeight			represents the height of our current vertex; used to calculate the intensity of the texture being mixed.
	 * - colourRange			represents the range away from the baseHeight (in both directions) that the texture coloring will drop off at.
	 * - apha					represents the alpha colour. mix provides the RGB values, and we set the alpha to 1.0.
	 *
	 * The height values used in the calculations below are hard-coded based on the usual numbers that are generated by our terrain algorithm.
	 * This could be made more robust by using the range between the lowest and highest point as a reference. There is also overlap of the textures
	 * for a smoother transition. 
	 */
	color = mix(diffuseSand,  color, min(abs( 400.0 - vPosition.y) / 500.0, 1.0)); // Maximum intensity at height = 400.0; 0% intensity at -100.0 and 900.0.
	color = mix(diffuseGrass, color, min(abs( 800.0 - vPosition.y) / 200.0, 1.0)); // Maximum intensity at height = 800.0; 0% intensity at 600.0 and 1000.0.
	color = mix(diffuseRock,  color, min(abs(1000.0 - vPosition.y) / 300.0, 1.0)); // Maximum intensity at height = 1000.0; 0% intensity at 700.0 and 1300.0.
	color = mix(diffuseSnow,  color, min(abs(1200.0 - vPosition.y) / 300.0, 1.0)); // Maximum intensity at height = 1200.0; 0% intensity at 900.0 and 1500.0.

	/* Apply our colour and adjust based on the light weighting. */
	gl_FragColor = vec4(color.rgb * vLightWeighting, color.a);
}